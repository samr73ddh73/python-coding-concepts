# Tree Theory - Quick Revision

## 1. Types of Binary Trees

**Strict Binary Tree**: Every node has either 0 or 2 children

**Full Binary Tree**: All leaf nodes at same level, all internal nodes have 2 children

**Complete Binary Tree**: All levels filled except possibly last, last level filled left to right

## 2. Properties of Binary Trees

**Height vs Nodes:**
- Height h=0 → 2^0 = 1 node
- Height h=1 → 2^1 = 2 nodes
- Height h → max 2^h nodes at that level

**Full Binary Tree:**
- Total nodes = 2^0 + 2^1 + ... + 2^h = 2^(h+1) - 1
- If n nodes → height h = log₂(n+1) - 1

## 3. Tree Traversals

**DFS (Depth-First Search):**
- **Inorder** (Left → Root → Right): BST gives sorted order
- **Preorder** (Root → Left → Right): Create copy, prefix expression
- **Postorder** (Left → Right → Root): Delete tree, postfix expression

**BFS (Breadth-First Search):**
- **Level Order**: Use queue, traverse level by level

## 4. Binary Search Tree (BST)

**Property**: Left < Root < Right

**Operations:**
- Search: O(h) where h = height
- Insert: O(h)
- Delete: O(h)

**Best case**: h = log n (balanced)
**Worst case**: h = n (skewed)

## 5. Balanced Trees

**AVL Tree**: |height(left) - height(right)| ≤ 1 for all nodes

**Red-Black Tree**: Self-balancing with color properties

**Goal**: Keep height = O(log n) → operations O(log n)

## 6. Common Patterns

**Height of Tree**: Post-order DFS, max(left, right) + 1

**Diameter**: Max distance between any two nodes

**Lowest Common Ancestor (LCA)**: First common ancestor of two nodes

**Path Sum**: DFS tracking current sum

**Serialize/Deserialize**: Convert tree ↔ string

**View Problems**: Left/Right/Top/Bottom view using level order + tracking

## 7. Time Complexities

| Operation | BST (avg) | BST (worst) | AVL/RB |
|-----------|-----------|-------------|---------|
| Search    | O(log n)  | O(n)        | O(log n)|
| Insert    | O(log n)  | O(n)        | O(log n)|
| Delete    | O(log n)  | O(n)        | O(log n)|
| Traversal | O(n)      | O(n)        | O(n)    |

## 8. Space Complexities

**Traversal**: O(h) for recursion stack
**Level Order**: O(w) where w = max width
**Balanced Tree**: O(log n) height
